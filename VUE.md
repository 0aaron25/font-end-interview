## vue相关面试题

#### 1.Virtual Dom 的优势在哪里？

「Virtual Dom 的优势」其实这道题目面试官更想听到的答案不是上来就说「直接操作/频繁操作 DOM 的性能差」，如果 DOM 操作的性能如此不堪，那么 jQuery 也不至于活到今天。所以面试官更想听到 VDOM 想解决的问题以及为什么频繁的 DOM 操作会性能差。

首先我们需要知道：

DOM 引擎、JS 引擎 相互独立，但又工作在同一线程（主线程）
JS 代码调用 DOM API 必须 挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，
引擎间切换的单位代价将迅速积累若其中有强制重绘的 DOM API 调用，重新计算布局、重新绘制图像会引起更大的性能消耗。

其次是 VDOM 和真实 DOM 的区别和优化：

1. 虚拟 DOM 不会立马进行排版与重绘操作

2. 虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多DOM节点排版与重绘损耗

3. 虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部

   

#### 2.Vue 的生命周期

Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载 Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是 Vue 的生命周期。通俗说就 是 Vue 实例从创建到销毁的过程，就是生命周期。 每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段:初始化、运行 中、销毁。
 实例、组件通过 new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行 beforeCreate 钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据 和真实的 dom，一般不做操作
 挂载数据，绑定事件等等，然后执行 created 函数，这个时候已经可以使用到数据，也 可以更改数据,在这里更改数据不会触发 updated 函数，在这里可以在渲染前倒数第二次 更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 接下来开始找实例或者组件对应的模板，编译模板为虚拟 dom 放入到 render 函数中准备 渲染，然后执行 beforeMount 钩子函数，在这个函数中虚拟 dom 已经创建完成，马上就 要渲染,在这里也可以更改数据，不会触发 updated，在这里可以在渲染前最后一次更改 数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 接下来开始 render，渲染出真实 dom，然后执行 mounted 钩子函数，此时，组件已经出 现在页面中，数据、真实 dom 都已经处理好了,事件都已经挂载好了，可以在这里操作 真实 dom 等事情...
 当组件或实例的数据更改之后，会立即执行 beforeUpdate，然后 Vue 的虚拟 dom 机制会 重新构建虚拟 dom 与上一次的虚拟 dom 树利用 diff 算法进行对比之后重新渲染，一般不 做什么事儿
 当更新完成后，执行 updated，数据已经更改完成，dom 也重新 render 完成，可以操作 更新后的虚拟 dom
 当经过某种途径调用$destroy 方法后，立即执行 beforeDestroy，一般在这里做一些善后工 作，例如清除计时器、清除非指令绑定的事件等等 组件的数据绑定、监听...去掉后只剩下 dom 空壳，这个时候，执行 destroyed，在这里做 善后工作也可以

#### 3.watch 和计算属性有什么区别?

通俗来讲，既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用 computed， 重点在于 computed 的缓存功能
 computed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量 改变时，计算属性也会跟着改变;
 watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。

#### 4.Vue 和 React 有什么不同?使用场景分别是什么?

1、Vue 是完整一套由官方维护的框架，核心库主要有由尤雨溪大神独自维护，而 React 是不要脸的书维护(很多库由社区维护)，曾经一段时间很多人质疑 Vue 的后续维护性， 似乎这并不是问题。
 2、Vue 上手简单，进阶式框架，白话说你可以学一点，就可以在你项目中去用一点， 你不一定需要一次性学习整个 Vue 才能去使用它，而 React，恐怕如果你这样会面对项 目束手无策。

3、语法上 Vue 并不限制你必须 es6+完全 js 形式编写页面，可以视图和 js 逻辑尽可能分 离，减少很多人看不惯 React-jsx 的恶心嵌套，毕竟都是作为前端开发者，还是更习惯 于 html 干净。
 4、很多人说 React 适合大型项目，适合什么什么，Vue 轻量级，适合移动端中小型项目， 其实我想说，说这话的人是心里根本没点逼数，Vue 完全可以应对复杂的大型应用，甚 至于说如果你 React 学的不是很好，写出来的东西或根本不如 Vue 写的，毕竟 Vue 跟着 官方文档撸就行，自有人帮你规范，而 React 比较懒散自由，可以自由发挥

5、Vue 在国内人气明显胜过 React，这很大程度上得益于它的很多语法包括编程思维更 符合国人思想。

#### 5.说说 Vue 的优缺点

1、数据驱动视图，对真实 dom 进行抽象出 virtual dom(本质就是一个 js 对象)， 并配合 diff 算法、响应式和观察者、异步队列等手段以最小代价更新 dom，渲染 页面 2、组件化，组件用单文件的形式进行代码的组织编写，使得我们可以在一个文 件里编写 html\css(scoped 属性配置 css 隔离)\js 并且配合 Vue-loader 之后，支 持更强大的预处理器等功能
 3、强大且丰富的 API 提供一系列的 api 能满足业务开发中各类需求 4、由于采用虚拟 dom，让 Vue ssr 先天就足 5、生命周期钩子函数，选项式的代码组织方式，写熟了还是蛮顺畅的，但仍然 有优化空间(Vue3 composition-api)
 6、生态好，社区活跃
 缺点:
 1、由于底层基于 Object.defineProperty 实现响应式，而这个 api 本身不支持 IE8 及以下浏览器
 2、csr 的先天不足，首屏性能问题(白屏) 3、由于百度等搜索引擎爬虫无法爬取 js 中的内容，故 spa 先天就对 seo 优化心 有余力不足(谷歌的 puppeteer 就挺牛逼的，实现预渲染底层也是用到了这个工 具)

#### 6.Vue3.0 里为什么要用 Proxy API 替代 defineProperty API?

响应式优化。
 a. defineProperty API 的局限性最大原因是它只能针对单例属性做监听。
 Vue2.x 中的响应式实现正是基于 defineProperty 中的 descriptor，对 data 中的属性做了遍 历 + 递归，为每个属性设置了 getter、setter。
 这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因，在 Vue 中使用 下标的方式直接修改属性的值或者添加一个预先不存在的对象属性是无法做到 setter 监 听的，这是 defineProperty 的局限性。
 b. Proxy API 的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这 就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。
 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须 先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。
 c. 响应式是惰性的
 在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要 递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的，这 无疑会有很大的性能消耗。
 在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的 处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响 应式，简单的可以说是按需实现响应式，减少性能消耗。
 基础用法:

![](/Users/liangjiahao/Pictures/截图图库/截屏2022-03-15 23.08.27.png)

#### 7.Vue3.0 编译做了哪些优化?

**a.** 生成 Block tree
 Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部 需要遍历该组 件的整个 vnode 树。在 2.0 里，渲染效率的快慢与组件大小成正相关:组件越大，渲染 效率越慢。并且，对于一些静态节点，又无数据更新，这些遍历都是性能浪费。
 Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了 Block tree。 Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个 区块内部的节点结构是固定的， 每个区块只需要追踪自身包含的动态节点。所以，在 3.0 里，渲染效率不再与模板大小 成正相关，而是与模板中动态节点的数量成正相关。

![](/Users/liangjiahao/Pictures/截图图库/截屏2022-03-15 23.09.34.png)

**b.** slot 编译优化
 Vue.js 2.x 中，如果有一个组件传入了 slot，那么每次父组件更新的时候，会强制使子组 件 update，造成性能的浪费。
 Vue.js 3.0 优化了 slot 的生成，使得非动态 slot 中属性的更新只会触发子组件的更新。 动态 slot 指的是在 slot 上面使用 v-if，v-for，动态 slot 名字等会导致 slot 产生运行时动 态变化但是又无法被子组件 track 的操作。
 c. diff 算法优化

#### 8.Vue3.0 是如何变得更快的?(底层，源码)

a. diff 方法优化
 Vue2.x 中的虚拟 dom 是进行全量的对比。
 Vue3.0 中新增了静态标记(PatchFlag):在与上次虚拟结点进行对比的时候，值对比 带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容化。

b. hoistStatic 静态提升
 Vue2.x : 无论元素是否参与更新，每次都会重新创建。
 Vue3.0 : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用。

 c. cacheHandlers 事件侦听器缓存
 默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一 个函数，所以没有追踪变化，直接缓存起来复用即可。

#### 9.vue 在 created 和 mounted 这两个生命周期中请求数据有什么区别呢?

看实际情况，一般在 created(或 beforeRouter) 里面就可以，如果涉及到需要页面加载 完成之后的话就用 mounted。
 在 created 的时候，视图中的 html 并没有渲染出来，所以此时如果直接去操作 html 的 dom 节点，一定找不到相关的元素
 而在 mounted 中，由于此时 html 已经渲染出来了，所以可以直接操作 dom 节点，(此 时 document.getelementById 即可生效了)。

#### 10.说说你对 proxy 的理解

vue 的数据劫持有两个缺点:
 1、无法监听通过索引修改数组的值的变化
 2、无法监听 object 也就是对象的值的变化
 所以 vue2.x 中才会有$set 属性的存在
 proxy 是 es6 中推出的新 api，可以弥补以上两个缺点，所以 vue3.x 版本用 proxy 替换 object.defineproperty。